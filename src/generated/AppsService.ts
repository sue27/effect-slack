/**
 * Generated Slack Apps Service
 * DO NOT EDIT - This file is auto-generated by scripts/generate-services.ts
 */

import { Effect } from "effect"
import type {
  AppsConnectionsOpenArguments,
  AppsConnectionsOpenResponse,
  AppsEventAuthorizationsListArguments,
  AppsEventAuthorizationsListResponse,
  AppsManifestCreateArguments,
  AppsManifestCreateResponse,
  AppsManifestDeleteArguments,
  AppsManifestDeleteResponse,
  AppsManifestExportArguments,
  AppsManifestExportResponse,
  AppsManifestUpdateArguments,
  AppsManifestUpdateResponse,
  AppsManifestValidateArguments,
  AppsManifestValidateResponse,
  AppsUninstallArguments,
  AppsUninstallResponse
} from "@slack/web-api"
import { SlackClient } from "../SlackClient.js"
import { mapSlackError, annotateSpanWithError, type SlackError } from "../internal/errors.js"

export class AppsService extends Effect.Service<AppsService>()("effect-slack/AppsService", {
  effect: Effect.gen(function* () {
    const client = yield* SlackClient

    /**
     * Uninstalls your app from a workspace.
     */
    const uninstall = (
      args: AppsUninstallArguments
    ): Effect.Effect<AppsUninstallResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.uninstall(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.uninstall", {
          attributes: { "slack.method": "apps.uninstall" }
        })
      )

    /**
     * Generate a temporary Socket Mode WebSocket URL that your app can connect to in order to receive events and interactive payloads over.
     */
    const ConnectionsOpen = (
      args?: AppsConnectionsOpenArguments
    ): Effect.Effect<AppsConnectionsOpenResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.connections.open(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.connections.open", {
          attributes: { "slack.method": "apps.connections.open" }
        })
      )

    /**
     * Get a list of authorizations for the given event context. Each authorization represents an app installation that the event is visible to.
     */
    const EventAuthorizationsList = (
      args: AppsEventAuthorizationsListArguments
    ): Effect.Effect<AppsEventAuthorizationsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.event.authorizations.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.event.authorizations.list", {
          attributes: { "slack.method": "apps.event.authorizations.list" }
        })
      )

    /**
     * Create an app from an app manifest.
     */
    const ManifestCreate = (
      args: AppsManifestCreateArguments
    ): Effect.Effect<AppsManifestCreateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.manifest.create(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.manifest.create", {
          attributes: { "slack.method": "apps.manifest.create" }
        })
      )

    /**
     * Permanently deletes an app created through app manifests.
     */
    const ManifestDelete_ = (
      args: AppsManifestDeleteArguments
    ): Effect.Effect<AppsManifestDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.manifest.delete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.manifest.delete_", {
          attributes: { "slack.method": "apps.manifest.delete" }
        })
      )

    /**
     * Export an app manifest from an existing app.
     */
    const ManifestExport_ = (
      args: AppsManifestExportArguments
    ): Effect.Effect<AppsManifestExportResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.manifest.export(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.manifest.export_", {
          attributes: { "slack.method": "apps.manifest.export" }
        })
      )

    /**
     * Update an app from an app manifest.
     */
    const ManifestUpdate = (
      args: AppsManifestUpdateArguments
    ): Effect.Effect<AppsManifestUpdateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.manifest.update(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.manifest.update", {
          attributes: { "slack.method": "apps.manifest.update" }
        })
      )

    /**
     * Validate an app manifest.
     */
    const ManifestValidate = (
      args: AppsManifestValidateArguments
    ): Effect.Effect<AppsManifestValidateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.apps.manifest.validate(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AppsService.manifest.validate", {
          attributes: { "slack.method": "apps.manifest.validate" }
        })
      )

    return {
      uninstall,
      connections: {
        open: ConnectionsOpen
      },
      event: {
        authorizations: {
          list: EventAuthorizationsList
        }
      },
      manifest: {
        create: ManifestCreate,
        delete_: ManifestDelete_,
        export_: ManifestExport_,
        update: ManifestUpdate,
        validate: ManifestValidate
      }
    } as const
  }),
  dependencies: [SlackClient.Default]
}) {}
