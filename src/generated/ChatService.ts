/**
 * Generated Slack Chat Service
 * DO NOT EDIT - This file is auto-generated by scripts/generate-services.ts
 */

import { Effect } from "effect"
import type {
  ChatAppendStreamArguments,
  ChatAppendStreamResponse,
  ChatDeleteArguments,
  ChatDeleteResponse,
  ChatDeleteScheduledMessageArguments,
  ChatDeleteScheduledMessageResponse,
  ChatGetPermalinkArguments,
  ChatGetPermalinkResponse,
  ChatMeMessageArguments,
  ChatMeMessageResponse,
  ChatPostEphemeralArguments,
  ChatPostEphemeralResponse,
  ChatPostMessageArguments,
  ChatPostMessageResponse,
  ChatScheduleMessageArguments,
  ChatScheduleMessageResponse,
  ChatScheduledMessagesListArguments,
  ChatScheduledMessagesListResponse,
  ChatStartStreamArguments,
  ChatStartStreamResponse,
  ChatStopStreamArguments,
  ChatStopStreamResponse,
  ChatUnfurlArguments,
  ChatUnfurlResponse,
  ChatUpdateArguments,
  ChatUpdateResponse
} from "@slack/web-api"
import { SlackClient } from "../SlackClient.js"
import { mapSlackError, annotateSpanWithError, type SlackError } from "../internal/errors.js"

export class ChatService extends Effect.Service<ChatService>()("effect-slack/ChatService", {
  effect: Effect.gen(function* () {
    const client = yield* SlackClient

    /**
     * Appends text to an existing streaming conversation.
     */
    const appendStream = (
      args: ChatAppendStreamArguments
    ): Effect.Effect<ChatAppendStreamResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.appendStream(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.appendStream", {
          attributes: { "slack.method": "chat.appendStream" }
        })
      )

    /**
     * Deletes a message.
     */
    const delete_ = (
      args: ChatDeleteArguments
    ): Effect.Effect<ChatDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.delete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.delete_", {
          attributes: { "slack.method": "chat.delete" }
        })
      )

    /**
     * Deletes a pending scheduled message from the queue.
     */
    const deleteScheduledMessage = (
      args: ChatDeleteScheduledMessageArguments
    ): Effect.Effect<ChatDeleteScheduledMessageResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.deleteScheduledMessage(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.deleteScheduledMessage", {
          attributes: { "slack.method": "chat.deleteScheduledMessage" }
        })
      )

    /**
     * Retrieve a permalink URL for a specific extant message.
     */
    const getPermalink = (
      args: ChatGetPermalinkArguments
    ): Effect.Effect<ChatGetPermalinkResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.getPermalink(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.getPermalink", {
          attributes: { "slack.method": "chat.getPermalink" }
        })
      )

    /**
     * Share a me message into a channel.
     */
    const meMessage = (
      args: ChatMeMessageArguments
    ): Effect.Effect<ChatMeMessageResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.meMessage(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.meMessage", {
          attributes: { "slack.method": "chat.meMessage" }
        })
      )

    /**
     * Sends an ephemeral message to a user in a channel.
     */
    const postEphemeral = (
      args: ChatPostEphemeralArguments
    ): Effect.Effect<ChatPostEphemeralResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.postEphemeral(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.postEphemeral", {
          attributes: { "slack.method": "chat.postEphemeral" }
        })
      )

    /**
     * Sends a message to a channel.
     */
    const postMessage = (
      args: ChatPostMessageArguments
    ): Effect.Effect<ChatPostMessageResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.postMessage(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.postMessage", {
          attributes: { "slack.method": "chat.postMessage" }
        })
      )

    /**
     * Schedules a message to be sent to a channel.
     */
    const scheduleMessage = (
      args: ChatScheduleMessageArguments
    ): Effect.Effect<ChatScheduleMessageResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.scheduleMessage(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.scheduleMessage", {
          attributes: { "slack.method": "chat.scheduleMessage" }
        })
      )

    /**
     * Starts a new streaming conversation.
     */
    const startStream = (
      args: ChatStartStreamArguments
    ): Effect.Effect<ChatStartStreamResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.startStream(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.startStream", {
          attributes: { "slack.method": "chat.startStream" }
        })
      )

    /**
     * Stops a streaming conversation.
     */
    const stopStream = (
      args: ChatStopStreamArguments
    ): Effect.Effect<ChatStopStreamResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.stopStream(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.stopStream", {
          attributes: { "slack.method": "chat.stopStream" }
        })
      )

    /**
     * Provide custom unfurl behavior for user-posted URLs.
     */
    const unfurl = (
      args: ChatUnfurlArguments
    ): Effect.Effect<ChatUnfurlResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.unfurl(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.unfurl", {
          attributes: { "slack.method": "chat.unfurl" }
        })
      )

    /**
     * Updates a message.
     */
    const update = (
      args: ChatUpdateArguments
    ): Effect.Effect<ChatUpdateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.update(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.update", {
          attributes: { "slack.method": "chat.update" }
        })
      )

    /**
     * Returns a list of scheduled messages.
     */
    const ScheduledMessagesList = (
      args?: ChatScheduledMessagesListArguments
    ): Effect.Effect<ChatScheduledMessagesListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.chat.scheduledMessages.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ChatService.scheduledMessages.list", {
          attributes: { "slack.method": "chat.scheduledMessages.list" }
        })
      )

    return {
      appendStream,
      delete_,
      deleteScheduledMessage,
      getPermalink,
      meMessage,
      postEphemeral,
      postMessage,
      scheduleMessage,
      startStream,
      stopStream,
      unfurl,
      update,
      scheduledMessages: {
        list: ScheduledMessagesList
      }
    } as const
  }),
  dependencies: [SlackClient.Default]
}) {}
