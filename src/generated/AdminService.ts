/**
 * Generated Slack Admin Service
 * DO NOT EDIT - This file is auto-generated by scripts/generate-services.ts
 */

import { Effect } from "effect"
import type {
  AdminAnalyticsGetFileArguments,
  AdminAnalyticsGetFileResponse,
  AdminAppsActivitiesListArguments,
  AdminAppsActivitiesListResponse,
  AdminAppsApproveArguments,
  AdminAppsApproveResponse,
  AdminAppsApprovedListArguments,
  AdminAppsApprovedListResponse,
  AdminAppsClearResolutionArguments,
  AdminAppsClearResolutionResponse,
  AdminAppsConfigLookupArguments,
  AdminAppsConfigLookupResponse,
  AdminAppsConfigSetArguments,
  AdminAppsConfigSetResponse,
  AdminAppsRequestsCancelArguments,
  AdminAppsRequestsCancelResponse,
  AdminAppsRequestsListArguments,
  AdminAppsRequestsListResponse,
  AdminAppsRestrictArguments,
  AdminAppsRestrictResponse,
  AdminAppsRestrictedListArguments,
  AdminAppsRestrictedListResponse,
  AdminAppsUninstallArguments,
  AdminAppsUninstallResponse,
  AdminAuthPolicyAssignEntitiesArguments,
  AdminAuthPolicyAssignEntitiesResponse,
  AdminAuthPolicyGetEntitiesArguments,
  AdminAuthPolicyGetEntitiesResponse,
  AdminAuthPolicyRemoveEntitiesArguments,
  AdminAuthPolicyRemoveEntitiesResponse,
  AdminBarriersCreateArguments,
  AdminBarriersCreateResponse,
  AdminBarriersDeleteArguments,
  AdminBarriersDeleteResponse,
  AdminBarriersListArguments,
  AdminBarriersListResponse,
  AdminBarriersUpdateArguments,
  AdminBarriersUpdateResponse,
  AdminConversationsArchiveArguments,
  AdminConversationsArchiveResponse,
  AdminConversationsBulkArchiveArguments,
  AdminConversationsBulkArchiveResponse,
  AdminConversationsBulkDeleteArguments,
  AdminConversationsBulkDeleteResponse,
  AdminConversationsBulkMoveArguments,
  AdminConversationsBulkMoveResponse,
  AdminConversationsConvertToPrivateArguments,
  AdminConversationsConvertToPrivateResponse,
  AdminConversationsConvertToPublicArguments,
  AdminConversationsConvertToPublicResponse,
  AdminConversationsCreateArguments,
  AdminConversationsCreateResponse,
  AdminConversationsDeleteArguments,
  AdminConversationsDeleteResponse,
  AdminConversationsDisconnectSharedArguments,
  AdminConversationsDisconnectSharedResponse,
  AdminConversationsEKMListOriginalConnectedChannelInfoArguments,
  AdminConversationsEkmListOriginalConnectedChannelInfoResponse,
  AdminConversationsGetConversationPrefsArguments,
  AdminConversationsGetConversationPrefsResponse,
  AdminConversationsGetCustomRetentionArguments,
  AdminConversationsGetCustomRetentionResponse,
  AdminConversationsGetTeamsArguments,
  AdminConversationsGetTeamsResponse,
  AdminConversationsInviteArguments,
  AdminConversationsInviteResponse,
  AdminConversationsLookupArguments,
  AdminConversationsLookupResponse,
  AdminConversationsRemoveCustomRetentionArguments,
  AdminConversationsRemoveCustomRetentionResponse,
  AdminConversationsRenameArguments,
  AdminConversationsRenameResponse,
  AdminConversationsRestrictAccessAddGroupArguments,
  AdminConversationsRestrictAccessAddGroupResponse,
  AdminConversationsRestrictAccessListGroupsArguments,
  AdminConversationsRestrictAccessListGroupsResponse,
  AdminConversationsRestrictAccessRemoveGroupArguments,
  AdminConversationsRestrictAccessRemoveGroupResponse,
  AdminConversationsSearchArguments,
  AdminConversationsSearchResponse,
  AdminConversationsSetConversationPrefsArguments,
  AdminConversationsSetConversationPrefsResponse,
  AdminConversationsSetCustomRetentionArguments,
  AdminConversationsSetCustomRetentionResponse,
  AdminConversationsSetTeamsArguments,
  AdminConversationsSetTeamsResponse,
  AdminConversationsUnarchiveArguments,
  AdminConversationsUnarchiveResponse,
  AdminEmojiAddAliasArguments,
  AdminEmojiAddAliasResponse,
  AdminEmojiAddArguments,
  AdminEmojiAddResponse,
  AdminEmojiListArguments,
  AdminEmojiListResponse,
  AdminEmojiRemoveArguments,
  AdminEmojiRemoveResponse,
  AdminEmojiRenameArguments,
  AdminEmojiRenameResponse,
  AdminFunctionsListArguments,
  AdminFunctionsListResponse,
  AdminFunctionsPermissionsLookupArguments,
  AdminFunctionsPermissionsLookupResponse,
  AdminFunctionsPermissionsSetArguments,
  AdminFunctionsPermissionsSetResponse,
  AdminInviteRequestsApproveArguments,
  AdminInviteRequestsApproveResponse,
  AdminInviteRequestsApprovedListArguments,
  AdminInviteRequestsApprovedListResponse,
  AdminInviteRequestsDeniedListArguments,
  AdminInviteRequestsDeniedListResponse,
  AdminInviteRequestsDenyArguments,
  AdminInviteRequestsDenyResponse,
  AdminInviteRequestsListArguments,
  AdminInviteRequestsListResponse,
  AdminRolesAddAssignmentsArguments,
  AdminRolesAddAssignmentsResponse,
  AdminRolesListAssignmentsArguments,
  AdminRolesListAssignmentsResponse,
  AdminRolesRemoveAssignmentsArguments,
  AdminRolesRemoveAssignmentsResponse,
  AdminTeamsAdminsListArguments,
  AdminTeamsAdminsListResponse,
  AdminTeamsCreateArguments,
  AdminTeamsCreateResponse,
  AdminTeamsListArguments,
  AdminTeamsListResponse,
  AdminTeamsOwnersListArguments,
  AdminTeamsOwnersListResponse,
  AdminTeamsSettingsInfoArguments,
  AdminTeamsSettingsInfoResponse,
  AdminTeamsSettingsSetDefaultChannelsArguments,
  AdminTeamsSettingsSetDefaultChannelsResponse,
  AdminTeamsSettingsSetDescriptionArguments,
  AdminTeamsSettingsSetDescriptionResponse,
  AdminTeamsSettingsSetDiscoverabilityArguments,
  AdminTeamsSettingsSetDiscoverabilityResponse,
  AdminTeamsSettingsSetIconArguments,
  AdminTeamsSettingsSetIconResponse,
  AdminTeamsSettingsSetNameArguments,
  AdminTeamsSettingsSetNameResponse,
  AdminUsergroupsAddChannelsArguments,
  AdminUsergroupsAddChannelsResponse,
  AdminUsergroupsAddTeamsArguments,
  AdminUsergroupsAddTeamsResponse,
  AdminUsergroupsListChannelsArguments,
  AdminUsergroupsListChannelsResponse,
  AdminUsergroupsRemoveChannelsArguments,
  AdminUsergroupsRemoveChannelsResponse,
  AdminUsersAssignArguments,
  AdminUsersAssignResponse,
  AdminUsersInviteArguments,
  AdminUsersInviteResponse,
  AdminUsersListArguments,
  AdminUsersListResponse,
  AdminUsersRemoveArguments,
  AdminUsersRemoveResponse,
  AdminUsersSessionClearSettingsArguments,
  AdminUsersSessionClearSettingsResponse,
  AdminUsersSessionGetSettingsArguments,
  AdminUsersSessionGetSettingsResponse,
  AdminUsersSessionInvalidateArguments,
  AdminUsersSessionInvalidateResponse,
  AdminUsersSessionListArguments,
  AdminUsersSessionListResponse,
  AdminUsersSessionResetArguments,
  AdminUsersSessionResetBulkArguments,
  AdminUsersSessionResetBulkResponse,
  AdminUsersSessionResetResponse,
  AdminUsersSessionSetSettingsArguments,
  AdminUsersSessionSetSettingsResponse,
  AdminUsersSetAdminArguments,
  AdminUsersSetAdminResponse,
  AdminUsersSetExpirationArguments,
  AdminUsersSetExpirationResponse,
  AdminUsersSetOwnerArguments,
  AdminUsersSetOwnerResponse,
  AdminUsersSetRegularArguments,
  AdminUsersSetRegularResponse,
  AdminUsersUnsupportedVersionsExportArguments,
  AdminUsersUnsupportedVersionsExportResponse,
  AdminWorkflowsCollaboratorsAddArguments,
  AdminWorkflowsCollaboratorsAddResponse,
  AdminWorkflowsCollaboratorsRemoveArguments,
  AdminWorkflowsCollaboratorsRemoveResponse,
  AdminWorkflowsPermissionsLookupArguments,
  AdminWorkflowsPermissionsLookupResponse,
  AdminWorkflowsSearchArguments,
  AdminWorkflowsSearchResponse,
  AdminWorkflowsUnpublishArguments,
  AdminWorkflowsUnpublishResponse
} from "@slack/web-api"
import { SlackClient } from "../SlackClient.js"
import { mapSlackError, annotateSpanWithError, type SlackError } from "../internal/errors.js"

export class AdminService extends Effect.Service<AdminService>()("effect-slack/AdminService", {
  effect: Effect.gen(function* () {
    const client = yield* SlackClient

    /**
     * Retrieve analytics data for a given date, presented as a compressed JSON file.
     */
    const AnalyticsGetFile = (
      args: AdminAnalyticsGetFileArguments
    ): Effect.Effect<AdminAnalyticsGetFileResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.analytics.getFile(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.analytics.getFile", {
          attributes: { "slack.method": "admin.analytics.getFile" }
        })
      )

    /**
     * Approve an app for installation on a workspace.
     */
    const AppsApprove = (
      args: AdminAppsApproveArguments
    ): Effect.Effect<AdminAppsApproveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.approve(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.approve", {
          attributes: { "slack.method": "admin.apps.approve" }
        })
      )

    /**
     * Clear an app resolution.
     */
    const AppsClearResolution = (
      args: AdminAppsClearResolutionArguments
    ): Effect.Effect<AdminAppsClearResolutionResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.clearResolution(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.clearResolution", {
          attributes: { "slack.method": "admin.apps.clearResolution" }
        })
      )

    /**
     * Restrict an app for installation on a workspace.
     */
    const AppsRestrict = (
      args: AdminAppsRestrictArguments
    ): Effect.Effect<AdminAppsRestrictResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.restrict(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.restrict", {
          attributes: { "slack.method": "admin.apps.restrict" }
        })
      )

    /**
     * Uninstall an app from one or many workspaces, or an entire enterprise organization.
     */
    const AppsUninstall = (
      args: AdminAppsUninstallArguments
    ): Effect.Effect<AdminAppsUninstallResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.uninstall(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.uninstall", {
          attributes: { "slack.method": "admin.apps.uninstall" }
        })
      )

    /**
     * Get logs for a specified team/org.
     */
    const AppsActivitiesList = (
      args?: AdminAppsActivitiesListArguments
    ): Effect.Effect<AdminAppsActivitiesListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.activities.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.activities.list", {
          attributes: { "slack.method": "admin.apps.activities.list" }
        })
      )

    /**
     * List approved apps for an org or workspace.
     */
    const AppsApprovedList = (
      args: AdminAppsApprovedListArguments
    ): Effect.Effect<AdminAppsApprovedListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.approved.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.approved.list", {
          attributes: { "slack.method": "admin.apps.approved.list" }
        })
      )

    /**
     * Look up the app config for connectors by their IDs.
     */
    const AppsConfigLookup = (
      args: AdminAppsConfigLookupArguments
    ): Effect.Effect<AdminAppsConfigLookupResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.config.lookup(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.config.lookup", {
          attributes: { "slack.method": "admin.apps.config.lookup" }
        })
      )

    /**
     * Set the app config for a connector.
     */
    const AppsConfigSet = (
      args: AdminAppsConfigSetArguments
    ): Effect.Effect<AdminAppsConfigSetResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.config.set(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.config.set", {
          attributes: { "slack.method": "admin.apps.config.set" }
        })
      )

    /**
     * Cancel app request for team.
     */
    const AppsRequestsCancel = (
      args: AdminAppsRequestsCancelArguments
    ): Effect.Effect<AdminAppsRequestsCancelResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.requests.cancel(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.requests.cancel", {
          attributes: { "slack.method": "admin.apps.requests.cancel" }
        })
      )

    /**
     * List app requests for a team/workspace.
     */
    const AppsRequestsList = (
      args: AdminAppsRequestsListArguments
    ): Effect.Effect<AdminAppsRequestsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.requests.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.requests.list", {
          attributes: { "slack.method": "admin.apps.requests.list" }
        })
      )

    /**
     * List restricted apps for an org or workspace.
     */
    const AppsRestrictedList = (
      args: AdminAppsRestrictedListArguments
    ): Effect.Effect<AdminAppsRestrictedListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.apps.restricted.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.apps.restricted.list", {
          attributes: { "slack.method": "admin.apps.restricted.list" }
        })
      )

    /**
     * Assign entities to a particular authentication policy.
     */
    const AuthPolicyAssignEntities = (
      args: AdminAuthPolicyAssignEntitiesArguments
    ): Effect.Effect<AdminAuthPolicyAssignEntitiesResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.auth.policy.assignEntities(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.auth.policy.assignEntities", {
          attributes: { "slack.method": "admin.auth.policy.assignEntities" }
        })
      )

    /**
     * Fetch all the entities assigned to a particular authentication policy by name.
     */
    const AuthPolicyGetEntities = (
      args: AdminAuthPolicyGetEntitiesArguments
    ): Effect.Effect<AdminAuthPolicyGetEntitiesResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.auth.policy.getEntities(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.auth.policy.getEntities", {
          attributes: { "slack.method": "admin.auth.policy.getEntities" }
        })
      )

    /**
     * Remove specified entities from a specified authentication policy.
     */
    const AuthPolicyRemoveEntities = (
      args: AdminAuthPolicyRemoveEntitiesArguments
    ): Effect.Effect<AdminAuthPolicyRemoveEntitiesResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.auth.policy.removeEntities(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.auth.policy.removeEntities", {
          attributes: { "slack.method": "admin.auth.policy.removeEntities" }
        })
      )

    /**
     * Create an Information Barrier.
     */
    const BarriersCreate = (
      args: AdminBarriersCreateArguments
    ): Effect.Effect<AdminBarriersCreateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.barriers.create(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.barriers.create", {
          attributes: { "slack.method": "admin.barriers.create" }
        })
      )

    /**
     * Delete an existing Information Barrier.
     */
    const BarriersDelete_ = (
      args: AdminBarriersDeleteArguments
    ): Effect.Effect<AdminBarriersDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.barriers.delete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.barriers.delete_", {
          attributes: { "slack.method": "admin.barriers.delete" }
        })
      )

    /**
     * Get all Information Barriers for your organization.
     */
    const BarriersList = (
      args?: AdminBarriersListArguments
    ): Effect.Effect<AdminBarriersListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.barriers.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.barriers.list", {
          attributes: { "slack.method": "admin.barriers.list" }
        })
      )

    /**
     * Update an existing Information Barrier.
     */
    const BarriersUpdate = (
      args: AdminBarriersUpdateArguments
    ): Effect.Effect<AdminBarriersUpdateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.barriers.update(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.barriers.update", {
          attributes: { "slack.method": "admin.barriers.update" }
        })
      )

    /**
     * Archive a public or private channel.
     */
    const ConversationsArchive = (
      args: AdminConversationsArchiveArguments
    ): Effect.Effect<AdminConversationsArchiveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.archive(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.archive", {
          attributes: { "slack.method": "admin.conversations.archive" }
        })
      )

    /**
     * Archive public or private channels in bulk.
     */
    const ConversationsBulkArchive = (
      args: AdminConversationsBulkArchiveArguments
    ): Effect.Effect<AdminConversationsBulkArchiveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.bulkArchive(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.bulkArchive", {
          attributes: { "slack.method": "admin.conversations.bulkArchive" }
        })
      )

    /**
     * Delete public or private channels in bulk.
     */
    const ConversationsBulkDelete = (
      args: AdminConversationsBulkDeleteArguments
    ): Effect.Effect<AdminConversationsBulkDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.bulkDelete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.bulkDelete", {
          attributes: { "slack.method": "admin.conversations.bulkDelete" }
        })
      )

    /**
     * Move public or private channels in bulk.
     */
    const ConversationsBulkMove = (
      args: AdminConversationsBulkMoveArguments
    ): Effect.Effect<AdminConversationsBulkMoveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.bulkMove(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.bulkMove", {
          attributes: { "slack.method": "admin.conversations.bulkMove" }
        })
      )

    /**
     * Convert a public channel to a private channel.
     */
    const ConversationsConvertToPrivate = (
      args: AdminConversationsConvertToPrivateArguments
    ): Effect.Effect<AdminConversationsConvertToPrivateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.convertToPrivate(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.convertToPrivate", {
          attributes: { "slack.method": "admin.conversations.convertToPrivate" }
        })
      )

    /**
     * Convert a private channel to a public channel.
     */
    const ConversationsConvertToPublic = (
      args: AdminConversationsConvertToPublicArguments
    ): Effect.Effect<AdminConversationsConvertToPublicResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.convertToPublic(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.convertToPublic", {
          attributes: { "slack.method": "admin.conversations.convertToPublic" }
        })
      )

    /**
     * Create a public or private channel-based conversation.
     */
    const ConversationsCreate = (
      args: AdminConversationsCreateArguments
    ): Effect.Effect<AdminConversationsCreateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.create(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.create", {
          attributes: { "slack.method": "admin.conversations.create" }
        })
      )

    /**
     * Delete a public or private channel.
     */
    const ConversationsDelete_ = (
      args: AdminConversationsDeleteArguments
    ): Effect.Effect<AdminConversationsDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.delete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.delete_", {
          attributes: { "slack.method": "admin.conversations.delete" }
        })
      )

    /**
     * Disconnect a connected channel from one or more workspaces.
     */
    const ConversationsDisconnectShared = (
      args: AdminConversationsDisconnectSharedArguments
    ): Effect.Effect<AdminConversationsDisconnectSharedResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.disconnectShared(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.disconnectShared", {
          attributes: { "slack.method": "admin.conversations.disconnectShared" }
        })
      )

    /**
     * Get conversation preferences for a public or private channel.
     */
    const ConversationsGetConversationPrefs = (
      args: AdminConversationsGetConversationPrefsArguments
    ): Effect.Effect<AdminConversationsGetConversationPrefsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.getConversationPrefs(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.getConversationPrefs", {
          attributes: { "slack.method": "admin.conversations.getConversationPrefs" }
        })
      )

    /**
     * Get a conversation's retention policy.
     */
    const ConversationsGetCustomRetention = (
      args: AdminConversationsGetCustomRetentionArguments
    ): Effect.Effect<AdminConversationsGetCustomRetentionResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.getCustomRetention(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.getCustomRetention", {
          attributes: { "slack.method": "admin.conversations.getCustomRetention" }
        })
      )

    /**
     * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
     */
    const ConversationsGetTeams = (
      args: AdminConversationsGetTeamsArguments
    ): Effect.Effect<AdminConversationsGetTeamsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.getTeams(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.getTeams", {
          attributes: { "slack.method": "admin.conversations.getTeams" }
        })
      )

    /**
     * Invite a user to a public or private channel.
     */
    const ConversationsInvite = (
      args: AdminConversationsInviteArguments
    ): Effect.Effect<AdminConversationsInviteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.invite(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.invite", {
          attributes: { "slack.method": "admin.conversations.invite" }
        })
      )

    /**
     * Returns channels on the given team using the filters.
     */
    const ConversationsLookup = (
      args: AdminConversationsLookupArguments
    ): Effect.Effect<AdminConversationsLookupResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.lookup(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.lookup", {
          attributes: { "slack.method": "admin.conversations.lookup" }
        })
      )

    /**
     * Remove a conversation's retention policy.
     */
    const ConversationsRemoveCustomRetention = (
      args: AdminConversationsRemoveCustomRetentionArguments
    ): Effect.Effect<AdminConversationsRemoveCustomRetentionResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.removeCustomRetention(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.removeCustomRetention", {
          attributes: { "slack.method": "admin.conversations.removeCustomRetention" }
        })
      )

    /**
     * Rename a public or private channel.
     */
    const ConversationsRename = (
      args: AdminConversationsRenameArguments
    ): Effect.Effect<AdminConversationsRenameResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.rename(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.rename", {
          attributes: { "slack.method": "admin.conversations.rename" }
        })
      )

    /**
     * Search for public or private channels in an Enterprise organization.
     */
    const ConversationsSearch = (
      args?: AdminConversationsSearchArguments
    ): Effect.Effect<AdminConversationsSearchResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.search(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.search", {
          attributes: { "slack.method": "admin.conversations.search" }
        })
      )

    /**
     * Set the posting permissions for a public or private channel.
     */
    const ConversationsSetConversationPrefs = (
      args: AdminConversationsSetConversationPrefsArguments
    ): Effect.Effect<AdminConversationsSetConversationPrefsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.setConversationPrefs(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.setConversationPrefs", {
          attributes: { "slack.method": "admin.conversations.setConversationPrefs" }
        })
      )

    /**
     * Set a conversation's retention policy.
     */
    const ConversationsSetCustomRetention = (
      args: AdminConversationsSetCustomRetentionArguments
    ): Effect.Effect<AdminConversationsSetCustomRetentionResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.setCustomRetention(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.setCustomRetention", {
          attributes: { "slack.method": "admin.conversations.setCustomRetention" }
        })
      )

    /**
     * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
     */
    const ConversationsSetTeams = (
      args: AdminConversationsSetTeamsArguments
    ): Effect.Effect<AdminConversationsSetTeamsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.setTeams(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.setTeams", {
          attributes: { "slack.method": "admin.conversations.setTeams" }
        })
      )

    /**
     * Unarchive a public or private channel.
     */
    const ConversationsUnarchive = (
      args: AdminConversationsUnarchiveArguments
    ): Effect.Effect<AdminConversationsUnarchiveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.unarchive(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.unarchive", {
          attributes: { "slack.method": "admin.conversations.unarchive" }
        })
      )

    /**
     * List all disconnected channels — i.e., channels that were once connected to other workspaces and then disconnected — and the corresponding original channel IDs for key revocation with EKM.
     */
    const ConversationsEkmListOriginalConnectedChannelInfo = (
      args?: AdminConversationsEKMListOriginalConnectedChannelInfoArguments
    ): Effect.Effect<AdminConversationsEkmListOriginalConnectedChannelInfoResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.ekm.listOriginalConnectedChannelInfo(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.ekm.listOriginalConnectedChannelInfo", {
          attributes: { "slack.method": "admin.conversations.ekm.listOriginalConnectedChannelInfo" }
        })
      )

    /**
     * Add an allowlist of IDP groups for accessing a channel.
     */
    const ConversationsRestrictAccessAddGroup = (
      args: AdminConversationsRestrictAccessAddGroupArguments
    ): Effect.Effect<AdminConversationsRestrictAccessAddGroupResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.restrictAccess.addGroup(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.restrictAccess.addGroup", {
          attributes: { "slack.method": "admin.conversations.restrictAccess.addGroup" }
        })
      )

    /**
     * List all IDP Groups linked to a channel.
     */
    const ConversationsRestrictAccessListGroups = (
      args: AdminConversationsRestrictAccessListGroupsArguments
    ): Effect.Effect<AdminConversationsRestrictAccessListGroupsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.restrictAccess.listGroups(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.restrictAccess.listGroups", {
          attributes: { "slack.method": "admin.conversations.restrictAccess.listGroups" }
        })
      )

    /**
     * Remove a linked IDP group linked from a private channel.
     */
    const ConversationsRestrictAccessRemoveGroup = (
      args: AdminConversationsRestrictAccessRemoveGroupArguments
    ): Effect.Effect<AdminConversationsRestrictAccessRemoveGroupResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.conversations.restrictAccess.removeGroup(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.conversations.restrictAccess.removeGroup", {
          attributes: { "slack.method": "admin.conversations.restrictAccess.removeGroup" }
        })
      )

    /**
     * Add an emoji.
     */
    const EmojiAdd = (
      args: AdminEmojiAddArguments
    ): Effect.Effect<AdminEmojiAddResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.emoji.add(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.emoji.add", {
          attributes: { "slack.method": "admin.emoji.add" }
        })
      )

    /**
     * Add an emoji alias.
     */
    const EmojiAddAlias = (
      args: AdminEmojiAddAliasArguments
    ): Effect.Effect<AdminEmojiAddAliasResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.emoji.addAlias(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.emoji.addAlias", {
          attributes: { "slack.method": "admin.emoji.addAlias" }
        })
      )

    /**
     * List emoji for an Enterprise Grid organization.
     */
    const EmojiList = (
      args?: AdminEmojiListArguments
    ): Effect.Effect<AdminEmojiListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.emoji.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.emoji.list", {
          attributes: { "slack.method": "admin.emoji.list" }
        })
      )

    /**
     * Remove an emoji across an Enterprise Grid organization.
     */
    const EmojiRemove = (
      args: AdminEmojiRemoveArguments
    ): Effect.Effect<AdminEmojiRemoveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.emoji.remove(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.emoji.remove", {
          attributes: { "slack.method": "admin.emoji.remove" }
        })
      )

    /**
     * Rename an emoji.
     */
    const EmojiRename = (
      args: AdminEmojiRenameArguments
    ): Effect.Effect<AdminEmojiRenameResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.emoji.rename(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.emoji.rename", {
          attributes: { "slack.method": "admin.emoji.rename" }
        })
      )

    /**
     * Look up functions by a set of apps.
     */
    const FunctionsList = (
      args: AdminFunctionsListArguments
    ): Effect.Effect<AdminFunctionsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.functions.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.functions.list", {
          attributes: { "slack.method": "admin.functions.list" }
        })
      )

    /**
     * Lookup the visibility of multiple Slack functions and include the users if it is limited to particular named entities.
     */
    const FunctionsPermissionsLookup = (
      args: AdminFunctionsPermissionsLookupArguments
    ): Effect.Effect<AdminFunctionsPermissionsLookupResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.functions.permissions.lookup(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.functions.permissions.lookup", {
          attributes: { "slack.method": "admin.functions.permissions.lookup" }
        })
      )

    /**
     * Set the visibility of a Slack function and define the users or workspaces if it is set to named_entities.
     */
    const FunctionsPermissionsSet = (
      args: AdminFunctionsPermissionsSetArguments
    ): Effect.Effect<AdminFunctionsPermissionsSetResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.functions.permissions.set(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.functions.permissions.set", {
          attributes: { "slack.method": "admin.functions.permissions.set" }
        })
      )

    /**
     * Approve a workspace invite request.
     */
    const InviteRequestsApprove = (
      args: AdminInviteRequestsApproveArguments
    ): Effect.Effect<AdminInviteRequestsApproveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.inviteRequests.approve(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.inviteRequests.approve", {
          attributes: { "slack.method": "admin.inviteRequests.approve" }
        })
      )

    /**
     * Deny a workspace invite request.
     */
    const InviteRequestsDeny = (
      args: AdminInviteRequestsDenyArguments
    ): Effect.Effect<AdminInviteRequestsDenyResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.inviteRequests.deny(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.inviteRequests.deny", {
          attributes: { "slack.method": "admin.inviteRequests.deny" }
        })
      )

    /**
     * List all pending workspace invite requests.
     */
    const InviteRequestsList = (
      args: AdminInviteRequestsListArguments
    ): Effect.Effect<AdminInviteRequestsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.inviteRequests.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.inviteRequests.list", {
          attributes: { "slack.method": "admin.inviteRequests.list" }
        })
      )

    /**
     * List all approved workspace invite requests.
     */
    const InviteRequestsApprovedList = (
      args: AdminInviteRequestsApprovedListArguments
    ): Effect.Effect<AdminInviteRequestsApprovedListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.inviteRequests.approved.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.inviteRequests.approved.list", {
          attributes: { "slack.method": "admin.inviteRequests.approved.list" }
        })
      )

    /**
     * List all denied workspace invite requests.
     */
    const InviteRequestsDeniedList = (
      args: AdminInviteRequestsDeniedListArguments
    ): Effect.Effect<AdminInviteRequestsDeniedListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.inviteRequests.denied.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.inviteRequests.denied.list", {
          attributes: { "slack.method": "admin.inviteRequests.denied.list" }
        })
      )

    /**
     * Adds members to the specified role with the specified scopes.
     */
    const RolesAddAssignments = (
      args: AdminRolesAddAssignmentsArguments
    ): Effect.Effect<AdminRolesAddAssignmentsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.roles.addAssignments(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.roles.addAssignments", {
          attributes: { "slack.method": "admin.roles.addAssignments" }
        })
      )

    /**
     * Lists assignments for all roles across entities. Options to scope results by any combination of roles or entities.
     */
    const RolesListAssignments = (
      args?: AdminRolesListAssignmentsArguments
    ): Effect.Effect<AdminRolesListAssignmentsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.roles.listAssignments(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.roles.listAssignments", {
          attributes: { "slack.method": "admin.roles.listAssignments" }
        })
      )

    /**
     * Removes a set of users from a role for the given scopes and entities.
     */
    const RolesRemoveAssignments = (
      args: AdminRolesRemoveAssignmentsArguments
    ): Effect.Effect<AdminRolesRemoveAssignmentsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.roles.removeAssignments(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.roles.removeAssignments", {
          attributes: { "slack.method": "admin.roles.removeAssignments" }
        })
      )

    /**
     * Create an Enterprise team.
     */
    const TeamsCreate = (
      args: AdminTeamsCreateArguments
    ): Effect.Effect<AdminTeamsCreateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.create(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.create", {
          attributes: { "slack.method": "admin.teams.create" }
        })
      )

    /**
     * List all teams on an Enterprise organization.
     */
    const TeamsList = (
      args?: AdminTeamsListArguments
    ): Effect.Effect<AdminTeamsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.list", {
          attributes: { "slack.method": "admin.teams.list" }
        })
      )

    /**
     * List all of the admins on a given workspace.
     */
    const TeamsAdminsList = (
      args: AdminTeamsAdminsListArguments
    ): Effect.Effect<AdminTeamsAdminsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.admins.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.admins.list", {
          attributes: { "slack.method": "admin.teams.admins.list" }
        })
      )

    /**
     * List all of the owners on a given workspace.
     */
    const TeamsOwnersList = (
      args: AdminTeamsOwnersListArguments
    ): Effect.Effect<AdminTeamsOwnersListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.owners.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.owners.list", {
          attributes: { "slack.method": "admin.teams.owners.list" }
        })
      )

    /**
     * Fetch information about settings in a workspace.
     */
    const TeamsSettingsInfo = (
      args: AdminTeamsSettingsInfoArguments
    ): Effect.Effect<AdminTeamsSettingsInfoResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.settings.info(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.settings.info", {
          attributes: { "slack.method": "admin.teams.settings.info" }
        })
      )

    /**
     * Set the default channels of a workspace.
     */
    const TeamsSettingsSetDefaultChannels = (
      args: AdminTeamsSettingsSetDefaultChannelsArguments
    ): Effect.Effect<AdminTeamsSettingsSetDefaultChannelsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.settings.setDefaultChannels(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.settings.setDefaultChannels", {
          attributes: { "slack.method": "admin.teams.settings.setDefaultChannels" }
        })
      )

    /**
     * Set the description of a given workspace.
     */
    const TeamsSettingsSetDescription = (
      args: AdminTeamsSettingsSetDescriptionArguments
    ): Effect.Effect<AdminTeamsSettingsSetDescriptionResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.settings.setDescription(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.settings.setDescription", {
          attributes: { "slack.method": "admin.teams.settings.setDescription" }
        })
      )

    /**
     * Set the discoverability of a given workspace.
     */
    const TeamsSettingsSetDiscoverability = (
      args: AdminTeamsSettingsSetDiscoverabilityArguments
    ): Effect.Effect<AdminTeamsSettingsSetDiscoverabilityResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.settings.setDiscoverability(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.settings.setDiscoverability", {
          attributes: { "slack.method": "admin.teams.settings.setDiscoverability" }
        })
      )

    /**
     * Sets the icon of a workspace.
     */
    const TeamsSettingsSetIcon = (
      args: AdminTeamsSettingsSetIconArguments
    ): Effect.Effect<AdminTeamsSettingsSetIconResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.settings.setIcon(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.settings.setIcon", {
          attributes: { "slack.method": "admin.teams.settings.setIcon" }
        })
      )

    /**
     * Set the name of a given workspace.
     */
    const TeamsSettingsSetName = (
      args: AdminTeamsSettingsSetNameArguments
    ): Effect.Effect<AdminTeamsSettingsSetNameResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.teams.settings.setName(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.teams.settings.setName", {
          attributes: { "slack.method": "admin.teams.settings.setName" }
        })
      )

    /**
     * Add up to one hundred default channels to an IDP group.
     */
    const UsergroupsAddChannels = (
      args: AdminUsergroupsAddChannelsArguments
    ): Effect.Effect<AdminUsergroupsAddChannelsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.usergroups.addChannels(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.usergroups.addChannels", {
          attributes: { "slack.method": "admin.usergroups.addChannels" }
        })
      )

    /**
     * Associate one or more default workspaces with an organization-wide IDP group.
     */
    const UsergroupsAddTeams = (
      args: AdminUsergroupsAddTeamsArguments
    ): Effect.Effect<AdminUsergroupsAddTeamsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.usergroups.addTeams(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.usergroups.addTeams", {
          attributes: { "slack.method": "admin.usergroups.addTeams" }
        })
      )

    /**
     * List the channels linked to an org-level IDP group (user group).
     */
    const UsergroupsListChannels = (
      args: AdminUsergroupsListChannelsArguments
    ): Effect.Effect<AdminUsergroupsListChannelsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.usergroups.listChannels(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.usergroups.listChannels", {
          attributes: { "slack.method": "admin.usergroups.listChannels" }
        })
      )

    /**
     * Remove one or more default channels from an org-level IDP group (user group).
     */
    const UsergroupsRemoveChannels = (
      args: AdminUsergroupsRemoveChannelsArguments
    ): Effect.Effect<AdminUsergroupsRemoveChannelsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.usergroups.removeChannels(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.usergroups.removeChannels", {
          attributes: { "slack.method": "admin.usergroups.removeChannels" }
        })
      )

    /**
     * Add an Enterprise user to a workspace.
     */
    const UsersAssign = (
      args: AdminUsersAssignArguments
    ): Effect.Effect<AdminUsersAssignResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.assign(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.assign", {
          attributes: { "slack.method": "admin.users.assign" }
        })
      )

    /**
     * Invite a user to a workspace.
     */
    const UsersInvite = (
      args: AdminUsersInviteArguments
    ): Effect.Effect<AdminUsersInviteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.invite(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.invite", {
          attributes: { "slack.method": "admin.users.invite" }
        })
      )

    /**
     * List users on a workspace.
     */
    const UsersList = (
      args?: AdminUsersListArguments
    ): Effect.Effect<AdminUsersListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.list", {
          attributes: { "slack.method": "admin.users.list" }
        })
      )

    /**
     * Remove a user from a workspace.
     */
    const UsersRemove = (
      args: AdminUsersRemoveArguments
    ): Effect.Effect<AdminUsersRemoveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.remove(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.remove", {
          attributes: { "slack.method": "admin.users.remove" }
        })
      )

    /**
     * Set an existing guest, regular user, or owner to be an admin user.
     */
    const UsersSetAdmin = (
      args: AdminUsersSetAdminArguments
    ): Effect.Effect<AdminUsersSetAdminResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.setAdmin(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.setAdmin", {
          attributes: { "slack.method": "admin.users.setAdmin" }
        })
      )

    /**
     * Set an expiration for a guest user.
     */
    const UsersSetExpiration = (
      args: AdminUsersSetExpirationArguments
    ): Effect.Effect<AdminUsersSetExpirationResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.setExpiration(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.setExpiration", {
          attributes: { "slack.method": "admin.users.setExpiration" }
        })
      )

    /**
     * Set an existing guest, regular user, or admin user to be a workspace owner.
     */
    const UsersSetOwner = (
      args: AdminUsersSetOwnerArguments
    ): Effect.Effect<AdminUsersSetOwnerResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.setOwner(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.setOwner", {
          attributes: { "slack.method": "admin.users.setOwner" }
        })
      )

    /**
     * Set an existing guest user, admin user, or owner to be a regular user.
     */
    const UsersSetRegular = (
      args: AdminUsersSetRegularArguments
    ): Effect.Effect<AdminUsersSetRegularResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.setRegular(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.setRegular", {
          attributes: { "slack.method": "admin.users.setRegular" }
        })
      )

    /**
     * Clear user-specific session settings—the session duration and what happens when the client closes—for a list of users.
     */
    const UsersSessionClearSettings = (
      args: AdminUsersSessionClearSettingsArguments
    ): Effect.Effect<AdminUsersSessionClearSettingsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.clearSettings(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.clearSettings", {
          attributes: { "slack.method": "admin.users.session.clearSettings" }
        })
      )

    /**
     * Get user-specific session settings—the session duration and what happens when the client closes—given a list of users.
     */
    const UsersSessionGetSettings = (
      args: AdminUsersSessionGetSettingsArguments
    ): Effect.Effect<AdminUsersSessionGetSettingsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.getSettings(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.getSettings", {
          attributes: { "slack.method": "admin.users.session.getSettings" }
        })
      )

    /**
     * Revoke a single session for a user. The user will be forced to login to Slack.
     */
    const UsersSessionInvalidate = (
      args: AdminUsersSessionInvalidateArguments
    ): Effect.Effect<AdminUsersSessionInvalidateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.invalidate(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.invalidate", {
          attributes: { "slack.method": "admin.users.session.invalidate" }
        })
      )

    /**
     * List active user sessions for an organization.
     */
    const UsersSessionList = (
      args?: AdminUsersSessionListArguments
    ): Effect.Effect<AdminUsersSessionListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.list", {
          attributes: { "slack.method": "admin.users.session.list" }
        })
      )

    /**
     * Wipes all valid sessions on all devices for a given user.
     */
    const UsersSessionReset = (
      args: AdminUsersSessionResetArguments
    ): Effect.Effect<AdminUsersSessionResetResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.reset(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.reset", {
          attributes: { "slack.method": "admin.users.session.reset" }
        })
      )

    /**
     * Enqueues an asynchronous job to wipe all valid sessions on all devices for a given user list.
     */
    const UsersSessionResetBulk = (
      args: AdminUsersSessionResetBulkArguments
    ): Effect.Effect<AdminUsersSessionResetBulkResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.resetBulk(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.resetBulk", {
          attributes: { "slack.method": "admin.users.session.resetBulk" }
        })
      )

    /**
     * Configure the user-level session settings—the session duration and what happens when the client closes—for one or more users.
     */
    const UsersSessionSetSettings = (
      args: AdminUsersSessionSetSettingsArguments
    ): Effect.Effect<AdminUsersSessionSetSettingsResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.session.setSettings(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.session.setSettings", {
          attributes: { "slack.method": "admin.users.session.setSettings" }
        })
      )

    /**
     * Ask Slackbot to send you an export listing all workspace members using unsupported software, presented as a zipped CSV file.
     */
    const UsersUnsupportedVersionsExport_ = (
      args: AdminUsersUnsupportedVersionsExportArguments
    ): Effect.Effect<AdminUsersUnsupportedVersionsExportResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.users.unsupportedVersions.export(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.users.unsupportedVersions.export_", {
          attributes: { "slack.method": "admin.users.unsupportedVersions.export" }
        })
      )

    /**
     * Search workflows within the team or enterprise.
     */
    const WorkflowsSearch = (
      args?: AdminWorkflowsSearchArguments
    ): Effect.Effect<AdminWorkflowsSearchResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.workflows.search(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.workflows.search", {
          attributes: { "slack.method": "admin.workflows.search" }
        })
      )

    /**
     * Unpublish workflows within the team or enterprise.
     */
    const WorkflowsUnpublish = (
      args: AdminWorkflowsUnpublishArguments
    ): Effect.Effect<AdminWorkflowsUnpublishResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.workflows.unpublish(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.workflows.unpublish", {
          attributes: { "slack.method": "admin.workflows.unpublish" }
        })
      )

    /**
     * Add collaborators to workflows within the team or enterprise.
     */
    const WorkflowsCollaboratorsAdd = (
      args: AdminWorkflowsCollaboratorsAddArguments
    ): Effect.Effect<AdminWorkflowsCollaboratorsAddResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.workflows.collaborators.add(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.workflows.collaborators.add", {
          attributes: { "slack.method": "admin.workflows.collaborators.add" }
        })
      )

    /**
     * Remove collaborators from workflows within the team or enterprise.
     */
    const WorkflowsCollaboratorsRemove = (
      args: AdminWorkflowsCollaboratorsRemoveArguments
    ): Effect.Effect<AdminWorkflowsCollaboratorsRemoveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.workflows.collaborators.remove(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.workflows.collaborators.remove", {
          attributes: { "slack.method": "admin.workflows.collaborators.remove" }
        })
      )

    /**
     * Look up the permissions for a set of workflows.
     */
    const WorkflowsPermissionsLookup = (
      args: AdminWorkflowsPermissionsLookupArguments
    ): Effect.Effect<AdminWorkflowsPermissionsLookupResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.admin.workflows.permissions.lookup(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("AdminService.workflows.permissions.lookup", {
          attributes: { "slack.method": "admin.workflows.permissions.lookup" }
        })
      )

    return {
      analytics: {
        getFile: AnalyticsGetFile
      },
      apps: {
        approve: AppsApprove,
        clearResolution: AppsClearResolution,
        restrict: AppsRestrict,
        uninstall: AppsUninstall,
        activities: {
          list: AppsActivitiesList
        },
        approved: {
          list: AppsApprovedList
        },
        config: {
          lookup: AppsConfigLookup,
          set: AppsConfigSet
        },
        requests: {
          cancel: AppsRequestsCancel,
          list: AppsRequestsList
        },
        restricted: {
          list: AppsRestrictedList
        }
      },
      auth: {
        policy: {
          assignEntities: AuthPolicyAssignEntities,
          getEntities: AuthPolicyGetEntities,
          removeEntities: AuthPolicyRemoveEntities
        }
      },
      barriers: {
        create: BarriersCreate,
        delete_: BarriersDelete_,
        list: BarriersList,
        update: BarriersUpdate
      },
      conversations: {
        archive: ConversationsArchive,
        bulkArchive: ConversationsBulkArchive,
        bulkDelete: ConversationsBulkDelete,
        bulkMove: ConversationsBulkMove,
        convertToPrivate: ConversationsConvertToPrivate,
        convertToPublic: ConversationsConvertToPublic,
        create: ConversationsCreate,
        delete_: ConversationsDelete_,
        disconnectShared: ConversationsDisconnectShared,
        getConversationPrefs: ConversationsGetConversationPrefs,
        getCustomRetention: ConversationsGetCustomRetention,
        getTeams: ConversationsGetTeams,
        invite: ConversationsInvite,
        lookup: ConversationsLookup,
        removeCustomRetention: ConversationsRemoveCustomRetention,
        rename: ConversationsRename,
        search: ConversationsSearch,
        setConversationPrefs: ConversationsSetConversationPrefs,
        setCustomRetention: ConversationsSetCustomRetention,
        setTeams: ConversationsSetTeams,
        unarchive: ConversationsUnarchive,
        ekm: {
          listOriginalConnectedChannelInfo: ConversationsEkmListOriginalConnectedChannelInfo
        },
        restrictAccess: {
          addGroup: ConversationsRestrictAccessAddGroup,
          listGroups: ConversationsRestrictAccessListGroups,
          removeGroup: ConversationsRestrictAccessRemoveGroup
        }
      },
      emoji: {
        add: EmojiAdd,
        addAlias: EmojiAddAlias,
        list: EmojiList,
        remove: EmojiRemove,
        rename: EmojiRename
      },
      functions: {
        list: FunctionsList,
        permissions: {
          lookup: FunctionsPermissionsLookup,
          set: FunctionsPermissionsSet
        }
      },
      inviteRequests: {
        approve: InviteRequestsApprove,
        deny: InviteRequestsDeny,
        list: InviteRequestsList,
        approved: {
          list: InviteRequestsApprovedList
        },
        denied: {
          list: InviteRequestsDeniedList
        }
      },
      roles: {
        addAssignments: RolesAddAssignments,
        listAssignments: RolesListAssignments,
        removeAssignments: RolesRemoveAssignments
      },
      teams: {
        create: TeamsCreate,
        list: TeamsList,
        admins: {
          list: TeamsAdminsList
        },
        owners: {
          list: TeamsOwnersList
        },
        settings: {
          info: TeamsSettingsInfo,
          setDefaultChannels: TeamsSettingsSetDefaultChannels,
          setDescription: TeamsSettingsSetDescription,
          setDiscoverability: TeamsSettingsSetDiscoverability,
          setIcon: TeamsSettingsSetIcon,
          setName: TeamsSettingsSetName
        }
      },
      usergroups: {
        addChannels: UsergroupsAddChannels,
        addTeams: UsergroupsAddTeams,
        listChannels: UsergroupsListChannels,
        removeChannels: UsergroupsRemoveChannels
      },
      users: {
        assign: UsersAssign,
        invite: UsersInvite,
        list: UsersList,
        remove: UsersRemove,
        setAdmin: UsersSetAdmin,
        setExpiration: UsersSetExpiration,
        setOwner: UsersSetOwner,
        setRegular: UsersSetRegular,
        session: {
          clearSettings: UsersSessionClearSettings,
          getSettings: UsersSessionGetSettings,
          invalidate: UsersSessionInvalidate,
          list: UsersSessionList,
          reset: UsersSessionReset,
          resetBulk: UsersSessionResetBulk,
          setSettings: UsersSessionSetSettings
        },
        unsupportedVersions: {
          export_: UsersUnsupportedVersionsExport_
        }
      },
      workflows: {
        search: WorkflowsSearch,
        unpublish: WorkflowsUnpublish,
        collaborators: {
          add: WorkflowsCollaboratorsAdd,
          remove: WorkflowsCollaboratorsRemove
        },
        permissions: {
          lookup: WorkflowsPermissionsLookup
        }
      }
    } as const
  }),
  dependencies: [SlackClient.Default]
}) {}
