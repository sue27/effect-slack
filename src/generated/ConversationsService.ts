/**
 * Generated Slack Conversations Service
 * DO NOT EDIT - This file is auto-generated by scripts/generate-services.ts
 */

import { Effect } from "effect"
import type {
  ConversationsAcceptSharedInviteArguments,
  ConversationsAcceptSharedInviteResponse,
  ConversationsApproveSharedInviteArguments,
  ConversationsApproveSharedInviteResponse,
  ConversationsArchiveArguments,
  ConversationsArchiveResponse,
  ConversationsCanvasesCreateArguments,
  ConversationsCanvasesCreateResponse,
  ConversationsCloseArguments,
  ConversationsCloseResponse,
  ConversationsCreateArguments,
  ConversationsCreateResponse,
  ConversationsDeclineSharedInviteArguments,
  ConversationsDeclineSharedInviteResponse,
  ConversationsExternalInvitePermissionsSetArguments,
  ConversationsExternalInvitePermissionsSetResponse,
  ConversationsHistoryArguments,
  ConversationsHistoryResponse,
  ConversationsInfoArguments,
  ConversationsInfoResponse,
  ConversationsInviteArguments,
  ConversationsInviteResponse,
  ConversationsInviteSharedArguments,
  ConversationsInviteSharedResponse,
  ConversationsJoinArguments,
  ConversationsJoinResponse,
  ConversationsKickArguments,
  ConversationsKickResponse,
  ConversationsLeaveArguments,
  ConversationsLeaveResponse,
  ConversationsListArguments,
  ConversationsListConnectInvitesArguments,
  ConversationsListConnectInvitesResponse,
  ConversationsListResponse,
  ConversationsMarkArguments,
  ConversationsMarkResponse,
  ConversationsMembersArguments,
  ConversationsMembersResponse,
  ConversationsOpenArguments,
  ConversationsOpenResponse,
  ConversationsRenameArguments,
  ConversationsRenameResponse,
  ConversationsRepliesArguments,
  ConversationsRepliesResponse,
  ConversationsRequestSharedInviteApproveArguments,
  ConversationsRequestSharedInviteApproveResponse,
  ConversationsRequestSharedInviteDenyArguments,
  ConversationsRequestSharedInviteDenyResponse,
  ConversationsRequestSharedInviteListArguments,
  ConversationsRequestSharedInviteListResponse,
  ConversationsSetPurposeArguments,
  ConversationsSetPurposeResponse,
  ConversationsSetTopicArguments,
  ConversationsSetTopicResponse,
  ConversationsUnarchiveArguments,
  ConversationsUnarchiveResponse
} from "@slack/web-api"
import { SlackClient } from "../SlackClient.js"
import { mapSlackError, annotateSpanWithError, type SlackError } from "../internal/errors.js"

export class ConversationsService extends Effect.Service<ConversationsService>()("effect-slack/ConversationsService", {
  effect: Effect.gen(function* () {
    const client = yield* SlackClient

    /**
     * Accepts an invitation to a Slack Connect channel.
     */
    const acceptSharedInvite = (
      args: ConversationsAcceptSharedInviteArguments
    ): Effect.Effect<ConversationsAcceptSharedInviteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.acceptSharedInvite(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.acceptSharedInvite", {
          attributes: { "slack.method": "conversations.acceptSharedInvite" }
        })
      )

    /**
     * Approves an invitation to a Slack Connect channel.
     */
    const approveSharedInvite = (
      args: ConversationsApproveSharedInviteArguments
    ): Effect.Effect<ConversationsApproveSharedInviteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.approveSharedInvite(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.approveSharedInvite", {
          attributes: { "slack.method": "conversations.approveSharedInvite" }
        })
      )

    /**
     * Archives a conversation.
     */
    const archive = (
      args: ConversationsArchiveArguments
    ): Effect.Effect<ConversationsArchiveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.archive(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.archive", {
          attributes: { "slack.method": "conversations.archive" }
        })
      )

    /**
     * Closes a direct message or multi-person direct message.
     */
    const close = (
      args: ConversationsCloseArguments
    ): Effect.Effect<ConversationsCloseResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.close(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.close", {
          attributes: { "slack.method": "conversations.close" }
        })
      )

    /**
     * Initiates a public or private channel-based conversation.
     */
    const create = (
      args: ConversationsCreateArguments
    ): Effect.Effect<ConversationsCreateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.create(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.create", {
          attributes: { "slack.method": "conversations.create" }
        })
      )

    /**
     * Declines an invitation to a Slack Connect channel.
     */
    const declineSharedInvite = (
      args: ConversationsDeclineSharedInviteArguments
    ): Effect.Effect<ConversationsDeclineSharedInviteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.declineSharedInvite(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.declineSharedInvite", {
          attributes: { "slack.method": "conversations.declineSharedInvite" }
        })
      )

    /**
     * Fetches a conversation's history of messages and events.
     */
    const history = (
      args: ConversationsHistoryArguments
    ): Effect.Effect<ConversationsHistoryResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.history(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.history", {
          attributes: { "slack.method": "conversations.history" }
        })
      )

    /**
     * Retrieve information about a conversation.
     */
    const info = (
      args: ConversationsInfoArguments
    ): Effect.Effect<ConversationsInfoResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.info(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.info", {
          attributes: { "slack.method": "conversations.info" }
        })
      )

    /**
     * Invites users to a channel.
     */
    const invite = (
      args: ConversationsInviteArguments
    ): Effect.Effect<ConversationsInviteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.invite(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.invite", {
          attributes: { "slack.method": "conversations.invite" }
        })
      )

    /**
     * Sends an invitation to a Slack Connect channel.
     */
    const inviteShared = (
      args: ConversationsInviteSharedArguments
    ): Effect.Effect<ConversationsInviteSharedResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.inviteShared(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.inviteShared", {
          attributes: { "slack.method": "conversations.inviteShared" }
        })
      )

    /**
     * Joins an existing conversation.
     */
    const join = (
      args: ConversationsJoinArguments
    ): Effect.Effect<ConversationsJoinResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.join(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.join", {
          attributes: { "slack.method": "conversations.join" }
        })
      )

    /**
     * Removes a user from a conversation.
     */
    const kick = (
      args: ConversationsKickArguments
    ): Effect.Effect<ConversationsKickResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.kick(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.kick", {
          attributes: { "slack.method": "conversations.kick" }
        })
      )

    /**
     * Leaves a conversation.
     */
    const leave = (
      args: ConversationsLeaveArguments
    ): Effect.Effect<ConversationsLeaveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.leave(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.leave", {
          attributes: { "slack.method": "conversations.leave" }
        })
      )

    /**
     * List all channels in a Slack team.
     */
    const list = (
      args?: ConversationsListArguments
    ): Effect.Effect<ConversationsListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.list", {
          attributes: { "slack.method": "conversations.list" }
        })
      )

    /**
     * Lists shared channel invites that have been generated or received but have not been approved by all parties.
     */
    const listConnectInvites = (
      args?: ConversationsListConnectInvitesArguments
    ): Effect.Effect<ConversationsListConnectInvitesResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.listConnectInvites(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.listConnectInvites", {
          attributes: { "slack.method": "conversations.listConnectInvites" }
        })
      )

    /**
     * Sets the read cursor in a channel.
     */
    const mark = (
      args: ConversationsMarkArguments
    ): Effect.Effect<ConversationsMarkResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.mark(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.mark", {
          attributes: { "slack.method": "conversations.mark" }
        })
      )

    /**
     * Retrieve members of a conversation.
     */
    const members = (
      args: ConversationsMembersArguments
    ): Effect.Effect<ConversationsMembersResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.members(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.members", {
          attributes: { "slack.method": "conversations.members" }
        })
      )

    /**
     * Opens or resumes a direct message or multi-person direct message.
     */
    const open = (
      args: ConversationsOpenArguments
    ): Effect.Effect<ConversationsOpenResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.open(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.open", {
          attributes: { "slack.method": "conversations.open" }
        })
      )

    /**
     * Renames a conversation.
     */
    const rename = (
      args: ConversationsRenameArguments
    ): Effect.Effect<ConversationsRenameResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.rename(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.rename", {
          attributes: { "slack.method": "conversations.rename" }
        })
      )

    /**
     * Retrieve a thread of messages posted to a conversation.
     */
    const replies = (
      args: ConversationsRepliesArguments
    ): Effect.Effect<ConversationsRepliesResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.replies(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.replies", {
          attributes: { "slack.method": "conversations.replies" }
        })
      )

    /**
     * Sets the purpose for a conversation.
     */
    const setPurpose = (
      args: ConversationsSetPurposeArguments
    ): Effect.Effect<ConversationsSetPurposeResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.setPurpose(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.setPurpose", {
          attributes: { "slack.method": "conversations.setPurpose" }
        })
      )

    /**
     * Sets the topic for a conversation.
     */
    const setTopic = (
      args: ConversationsSetTopicArguments
    ): Effect.Effect<ConversationsSetTopicResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.setTopic(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.setTopic", {
          attributes: { "slack.method": "conversations.setTopic" }
        })
      )

    /**
     * Reverses conversation archival.
     */
    const unarchive = (
      args: ConversationsUnarchiveArguments
    ): Effect.Effect<ConversationsUnarchiveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.unarchive(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.unarchive", {
          attributes: { "slack.method": "conversations.unarchive" }
        })
      )

    /**
     * Create a Channel Canvas for a channel.
     */
    const CanvasesCreate = (
      args: ConversationsCanvasesCreateArguments
    ): Effect.Effect<ConversationsCanvasesCreateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.canvases.create(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.canvases.create", {
          attributes: { "slack.method": "conversations.canvases.create" }
        })
      )

    /**
     * Convert a team in a shared channel from an External Limited channel to a fully shared Slack Connect channel or vice versa.
     */
    const ExternalInvitePermissionsSet = (
      args: ConversationsExternalInvitePermissionsSetArguments
    ): Effect.Effect<ConversationsExternalInvitePermissionsSetResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.externalInvitePermissions.set(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.externalInvitePermissions.set", {
          attributes: { "slack.method": "conversations.externalInvitePermissions.set" }
        })
      )

    /**
     * Approves a request to add an external user to a channel and sends them a Slack Connect invite.
     */
    const RequestSharedInviteApprove = (
      args: ConversationsRequestSharedInviteApproveArguments
    ): Effect.Effect<ConversationsRequestSharedInviteApproveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.requestSharedInvite.approve(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.requestSharedInvite.approve", {
          attributes: { "slack.method": "conversations.requestSharedInvite.approve" }
        })
      )

    /**
     * Denies a request to invite an external user to a channel.
     */
    const RequestSharedInviteDeny = (
      args: ConversationsRequestSharedInviteDenyArguments
    ): Effect.Effect<ConversationsRequestSharedInviteDenyResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.requestSharedInvite.deny(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.requestSharedInvite.deny", {
          attributes: { "slack.method": "conversations.requestSharedInvite.deny" }
        })
      )

    /**
     * Lists requests to add external users to channels with ability to filter.
     */
    const RequestSharedInviteList = (
      args?: ConversationsRequestSharedInviteListArguments
    ): Effect.Effect<ConversationsRequestSharedInviteListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.conversations.requestSharedInvite.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("ConversationsService.requestSharedInvite.list", {
          attributes: { "slack.method": "conversations.requestSharedInvite.list" }
        })
      )

    return {
      acceptSharedInvite,
      approveSharedInvite,
      archive,
      close,
      create,
      declineSharedInvite,
      history,
      info,
      invite,
      inviteShared,
      join,
      kick,
      leave,
      list,
      listConnectInvites,
      mark,
      members,
      open,
      rename,
      replies,
      setPurpose,
      setTopic,
      unarchive,
      canvases: {
        create: CanvasesCreate
      },
      externalInvitePermissions: {
        set: ExternalInvitePermissionsSet
      },
      requestSharedInvite: {
        approve: RequestSharedInviteApprove,
        deny: RequestSharedInviteDeny,
        list: RequestSharedInviteList
      }
    } as const
  }),
  dependencies: [SlackClient.Default]
}) {}
