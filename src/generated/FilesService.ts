/**
 * Generated Slack Files Service
 * DO NOT EDIT - This file is auto-generated by scripts/generate-services.ts
 */

import { Effect } from "effect"
import type {
  FilesCommentsDeleteArguments,
  FilesCommentsDeleteResponse,
  FilesCompleteUploadExternalArguments,
  FilesCompleteUploadExternalResponse,
  FilesDeleteArguments,
  FilesDeleteResponse,
  FilesGetUploadURLExternalArguments,
  FilesGetUploadURLExternalResponse,
  FilesInfoArguments,
  FilesInfoResponse,
  FilesListArguments,
  FilesListResponse,
  FilesRemoteAddArguments,
  FilesRemoteAddResponse,
  FilesRemoteInfoArguments,
  FilesRemoteInfoResponse,
  FilesRemoteListArguments,
  FilesRemoteListResponse,
  FilesRemoteRemoveArguments,
  FilesRemoteRemoveResponse,
  FilesRemoteShareArguments,
  FilesRemoteShareResponse,
  FilesRemoteUpdateArguments,
  FilesRemoteUpdateResponse,
  FilesRevokePublicURLArguments,
  FilesRevokePublicURLResponse,
  FilesSharedPublicURLArguments,
  FilesSharedPublicURLResponse,
  FilesUploadArguments,
  FilesUploadResponse,
  FilesUploadV2Arguments,
  WebAPICallResult
} from "@slack/web-api"
import { SlackClient } from "../SlackClient.js"
import { mapSlackError, annotateSpanWithError, type SlackError } from "../internal/errors.js"

export class FilesService extends Effect.Service<FilesService>()("effect-slack/FilesService", {
  effect: Effect.gen(function* () {
    const client = yield* SlackClient

    /**
     * Finishes an upload started with {@link https://docs.slack.dev/reference/methods/files.getUploadURLExternal `files.getUploadURLExternal`}.
     */
    const completeUploadExternal = (
      args: FilesCompleteUploadExternalArguments
    ): Effect.Effect<FilesCompleteUploadExternalResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.completeUploadExternal(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.completeUploadExternal", {
          attributes: { "slack.method": "files.completeUploadExternal" }
        })
      )

    /**
     * Deletes a file.
     */
    const delete_ = (
      args: FilesDeleteArguments
    ): Effect.Effect<FilesDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.delete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.delete_", {
          attributes: { "slack.method": "files.delete" }
        })
      )

    /**
     * Gets a URL for an edge external file upload.
     */
    const getUploadURLExternal = (
      args: FilesGetUploadURLExternalArguments
    ): Effect.Effect<FilesGetUploadURLExternalResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.getUploadURLExternal(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.getUploadURLExternal", {
          attributes: { "slack.method": "files.getUploadURLExternal" }
        })
      )

    /**
     * Gets information about a file.
     */
    const info = (
      args: FilesInfoArguments
    ): Effect.Effect<FilesInfoResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.info(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.info", {
          attributes: { "slack.method": "files.info" }
        })
      )

    /**
     * List files for a team, in a channel, or from a user with applied filters.
     */
    const list = (
      args: FilesListArguments
    ): Effect.Effect<FilesListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.list", {
          attributes: { "slack.method": "files.list" }
        })
      )

    /**
     * Revokes public/external sharing access for a file.
     */
    const revokePublicURL = (
      args: FilesRevokePublicURLArguments
    ): Effect.Effect<FilesRevokePublicURLResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.revokePublicURL(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.revokePublicURL", {
          attributes: { "slack.method": "files.revokePublicURL" }
        })
      )

    /**
     * Enables a file for public/external sharing.
     */
    const sharedPublicURL = (
      args: FilesSharedPublicURLArguments
    ): Effect.Effect<FilesSharedPublicURLResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.sharedPublicURL(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.sharedPublicURL", {
          attributes: { "slack.method": "files.sharedPublicURL" }
        })
      )

    /**
     * Uploads or creates a file.
     * @deprecated
     */
    const upload = (
      args: FilesUploadArguments
    ): Effect.Effect<FilesUploadResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.upload(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.upload", {
          attributes: { "slack.method": "files.upload" }
        })
      )

    /**
     * Custom method to support a new way of uploading files to Slack. Supports a single file upload Supply: - (required) single file or content - (optional) channel, alt_text, snippet_type, Supports multiple file uploads Supply: - multiple upload_files Will try to honor both single file or content data supplied as well as multiple file uploads property.
     */
    const uploadV2 = (
      args: FilesUploadV2Arguments
    ): Effect.Effect<WebAPICallResult, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.uploadV2(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.uploadV2", {
          attributes: { "slack.method": "files.uploadV2" }
        })
      )

    /**
     * Deletes an existing comment on a file.
     */
    const CommentsDelete_ = (
      args: FilesCommentsDeleteArguments
    ): Effect.Effect<FilesCommentsDeleteResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.comments.delete(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.comments.delete_", {
          attributes: { "slack.method": "files.comments.delete" }
        })
      )

    /**
     * Adds a file from a remote service.
     */
    const RemoteAdd = (
      args: FilesRemoteAddArguments
    ): Effect.Effect<FilesRemoteAddResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.remote.add(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.remote.add", {
          attributes: { "slack.method": "files.remote.add" }
        })
      )

    /**
     * Retrieve information about a remote file added to Slack.
     */
    const RemoteInfo = (
      args: FilesRemoteInfoArguments
    ): Effect.Effect<FilesRemoteInfoResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.remote.info(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.remote.info", {
          attributes: { "slack.method": "files.remote.info" }
        })
      )

    /**
     * List remote files added to Slack.
     */
    const RemoteList = (
      args: FilesRemoteListArguments
    ): Effect.Effect<FilesRemoteListResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.remote.list(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.remote.list", {
          attributes: { "slack.method": "files.remote.list" }
        })
      )

    /**
     * Remove a remote file.
     */
    const RemoteRemove = (
      args: FilesRemoteRemoveArguments
    ): Effect.Effect<FilesRemoteRemoveResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.remote.remove(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.remote.remove", {
          attributes: { "slack.method": "files.remote.remove" }
        })
      )

    /**
     * Share a remote file into a channel.
     */
    const RemoteShare = (
      args: FilesRemoteShareArguments
    ): Effect.Effect<FilesRemoteShareResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.remote.share(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.remote.share", {
          attributes: { "slack.method": "files.remote.share" }
        })
      )

    /**
     * Updates an existing remote file.
     */
    const RemoteUpdate = (
      args: FilesRemoteUpdateArguments
    ): Effect.Effect<FilesRemoteUpdateResponse, SlackError> =>
      Effect.tryPromise({
        try: () => client.files.remote.update(args),
        catch: mapSlackError
      }).pipe(
        Effect.tapError(annotateSpanWithError),
        Effect.withSpan("FilesService.remote.update", {
          attributes: { "slack.method": "files.remote.update" }
        })
      )

    return {
      completeUploadExternal,
      delete_,
      getUploadURLExternal,
      info,
      list,
      revokePublicURL,
      sharedPublicURL,
      upload,
      uploadV2,
      comments: {
        delete_: CommentsDelete_
      },
      remote: {
        add: RemoteAdd,
        info: RemoteInfo,
        list: RemoteList,
        remove: RemoteRemove,
        share: RemoteShare,
        update: RemoteUpdate
      }
    } as const
  }),
  dependencies: [SlackClient.Default]
}) {}
